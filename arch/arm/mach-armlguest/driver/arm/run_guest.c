/*
 *  linux/arch/arm/mach-armlguest/driver/arm/run_guest.c
 *
 *  Copyright (C) 2009 Mingli Wu. (myfavor_linux@msn.com)
 *
 *  This code is based on the linux/driver/lguest/x86/core.c,
 *  written by Rusty Russell.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 */

 
#include <linux/kernel.h>
#include <linux/start_kernel.h>
#include <linux/string.h>
#include <linux/console.h>
#include <linux/screen_info.h>
#include <linux/irq.h>
#include <linux/interrupt.h>
#include <linux/clocksource.h>
#include <linux/clockchips.h>
#include <linux/cpu.h>
#include <linux/lguest.h>
#include <linux/lguest_launcher.h>
#include <linux/sched.h>
#include <asm/param.h>
#include <asm/page.h>
#include <asm/pgtable.h>
#include <asm/setup.h>
#include <asm/lguest.h>
#include <asm/uaccess.h>
#include <asm/cputype.h>
#include <asm/cputype.h>
#include <asm/system.h>
#include <asm/mach-types.h>
#include "../lg.h"

extern int cpu_architecture(void);
/*
 * The Host and the Guest communicate with each other by two ways. one is 
 * through a hypercall, the other is by "struct lguest_regs" which is located
 * on the first page of "struct lguest_pages".
 * please see linux/arch/arm/mach-armlguest/driver/lg.h and 
 * linux/arch/arm/include/asm/lguest.h.  
 */


/*-------------The first page of "struct lguest_pages"----------------------*/

/*              
                -----------------------------------------------------------------   
                |                                                       |   |	
                |                                                       |   |
                |                                                       |   |   
                |          "struct lguest_regs regs"                    |   |
                |                                                       |   |
                |                                                       |   |
                |                                                       |   |
                |                                                       |   |
                ---------------------------------------------------------   |
                |                                                       |   |
                |                                                       |
                |                                                       |
                |                                                       |	4K
                |     "unsigned char guest_svc_stack[SPARE_SIZE]"       |
                |                                                       |
    ------------|                                                       |   |
    |           |                                                       |   |
    |           |                                                       |   |
    |           ---------------------------------------------------------   |	
    |           |                                                       |   |
    |           |            "unsigned long spare[2]"                   |   |	 
    |           |              8 bytes spare space                      |   |	
    |           |                                                       |   |
    |           ----------------------------------------------------------------
    |
    |
    V
	When the Guest runs, if Exceptions are generated by internal and external sources, Such as 
	an interrupt, a Data Abort, a Prefetch Abort or attempting to execute an undefined instruction,
	the Guest's exception handler will change CPU to SVC mode first(saving the context, then going 
	back to the Host), at this pointer, this area is used as the stack for Switcher before we return 
	to the Host. (if a system call or a hypercall happens, The CPU will automatically change to SVC
	mode) Also, When Switcher has changed MMU to the Guest'setting, at this pointer, CPU still works 
	under SVC mode, this area is used as the stack for Switcher before we restore the Guest to run.	
*/





/* Offset from where switcher.S was compiled to where we've copied it */
static unsigned long switcher_offset(void)
{
	return get_switcher_addr() - (unsigned long)start_switcher_text;
}


/* This cpu's struct lguest_pages. */
static struct lguest_pages *lguest_pages(unsigned int cpu)
{

	return &(((struct lguest_pages *)
			(get_switcher_addr() + SHARED_SWITCHER_PAGES*PAGE_SIZE))[cpu]);	
}


/*S:010
 * We approach the Switcher.
 *
 * Remember that each CPU has two pages which are visible to the Guest when it
 * runs on that CPU.  This has to contain the state for that Guest: we copy the
 * state in just before we run the Guest.
 */
static void copy_in_guest_info(struct lg_cpu *cpu, struct lguest_pages *pages)
{
	/* Tell the Switcher the Guest's shadow page table pointer */
	cpu->regs->guest_pgd0 = __pa(cpu->lg->pgdirs[cpu->cpu_pgd].pgdir);
	/*
	 * Set up the Guest's page tables to see this CPU's pages (and no
	 * other CPU's pages).
	 */
	map_switcher_in_guest(cpu, pages);

	/* Please see the comments in switcher.S about this "sp"*/
	cpu->regs->gregs.ARM_sp = (unsigned long)(pages) + cpu->regs->guest_sp_offset;
}


typedef void (* lguest_switcher_f) (unsigned long pages, unsigned long hregs);

/* Finally: the code to actually call into the Switcher to run the Guest. */
static void run_guest_once(struct lg_cpu *cpu, struct lguest_pages *pages)
{
	lguest_switcher_f to_guest;
	/*
	 * Copy the guest-specific information into this CPU's "struct
	 * lguest_pages".
	 */
	copy_in_guest_info(cpu, pages);

	/* NOw to_guest = switch_to_guest. please see switcher.S*/
    to_guest = (lguest_switcher_f)((unsigned long)switch_to_guest + switcher_offset());
	to_guest((unsigned long)pages, (unsigned long)cpu->regs);
}

/*:*/

/*H:040
 * Interrupts are disabled: we own the CPU.
 */
void lguest_arch_run_guest(struct lg_cpu *cpu)
{
	/*
	 * Now we actually run the Guest.  It will return when something
	 * interesting happens, and we can examine its registers to see what it
	 * was doing.
	 */
	run_guest_once(cpu, lguest_pages(raw_smp_processor_id()));
}



/*H:050 Once we've re-enabled interrupts, we look at why the Guest exited. */
void lguest_arch_handle_return(struct lg_cpu *cpu)
{
		bool ret;

		switch(cpu->regs->guest_retcode){
			case RET_UNF:
				/* 
				 * The Guest encounters a undefined instruction. We do nothing here, 
				 * and let the Guest handle it.
				 */
				break;

			case RET_HCALL:
				/*
				 * The Guest send a hypercall to the Host.
				 */
				do_hypercalls(cpu);
				break;

			case RET_PABT:
				/*
				 * A prefetch abort happened.
				 */
				ret = guest_abort_handler(cpu, cpu->regs->gregs.ARM_r0, 
											cpu->regs->gregs.ARM_r1 | FSR_LNX_PF);
				/*
				 * (ret == false) means that the Host cannot solve it, the Guest will handle it.
				 * Otherwise, the problem is solved.
				 */
				if(ret == false){
					cpu->regs->gregs.ARM_r4 = 1;
				} else {
					cpu->regs->gregs.ARM_r4 = 0;
				}
				break;

			case RET_DABT:
				/*
				 * A data abort happened
				 */
				ret = guest_abort_handler(cpu, cpu->regs->gregs.ARM_r0, cpu->regs->gregs.ARM_r1);
				/*
				 * (ret == false) means that the Host cannot solve it, the Guest will handle it.
				 * Otherwise, the problem is solved.
				 */
				if(ret == false){
					cpu->regs->gregs.ARM_r4 = 1;
				} else {
					cpu->regs->gregs.ARM_r4 = 0;
				}
				break;

			case RET_IRQ:
				/*
				 * A real interrupt occurred, in which case the Host handler has 
				 * already been run. We just do a friendly check if another process 
				 * should now be run, then return to run the Guest again.
				 */
				cond_resched();
				break;

			case RET_GSYSCALL:
				/*
				 * The Guest kernel receive a system call, we need to do nothing here.
				 */
				break;
			default:
				kill_guest(cpu, "don't know why guest come back, return code %ld\n", cpu->regs->guest_retcode);					
		}
		return;
}


/* We may do something here in the future */
int lguest_arch_do_hcall(struct lg_cpu *cpu, struct hcall_args *args)
{

	return 1;
}


/* We may do something here in the future */
int lguest_arch_init_hypercalls(struct lg_cpu *cpu)
{

	return 0;
}

/* We may do something here in the future */
void __init lguest_arch_host_init(void)
{

}


/*:*/



/*L:030
 * lguest_arch_setup_regs()
 * The Guest set r0, r1, r2, r9 and cspr for the Guest to start,
 * and set some members of "struct lguest_regs"
 */
void lguest_arch_setup_regs(struct lg_cpu *cpu, unsigned long start)
{
	struct lguest_regs *regs = cpu->regs;

	struct hcall_args *hcalls = regs->hcalls;
	int i;
	unsigned int gcopro;


    /* Set up the Guest's page tables to map low level vectors of the Guest */
	map_vectors_in_guest(cpu, GUEST_VECTOR_ADDRESS);

	/* Switcher code will set domain register for the Guest according to this value */
	regs->guest_domain = (domain_val(DOMAIN_USER, DOMAIN_MANAGER) | \
						domain_val(DOMAIN_KERNEL, DOMAIN_MANAGER) | \
						domain_val(DOMAIN_TABLE, DOMAIN_MANAGER) | \
						domain_val(DOMAIN_IO, DOMAIN_CLIENT));



	/* r0  = cp#15 control register */
	regs->gregs.ARM_r0 = cr_alignment; 
	regs->guest_ctrl = cr_alignment;
	/* r1  = machine ID. please see linux/arch/arm/include/asm/mach-types.h*/
	regs->gregs.ARM_r1 = MACH_TYPE_ARMLGUEST;
	/* r2  = atags pointer */
	regs->gregs.ARM_r2 = 0x80000100;
	/* r9  = processor ID*/
	regs->gregs.ARM_r9 = GUEST_PROCESSOR_ID;

	/* 
	 * The address of the Guest startup entry.
	 * Please see linux/arch/arm/mach-armlguest/kernel/lguest-entry-armv.S
	 */
	regs->gregs.ARM_pc = GUEST_KERNEL_START;

	regs->gregs.ARM_cpsr = PSR_F_BIT | PSR_I_BIT | SVC_MODE;

	
	/* 
	 * Save the cpu id, cache type and tlb type on "struct lguest_regs" 
	 * when the Guest needs to these values the can get from there.
	 */
	regs->guest_cpuid_id = GUEST_PROCESSOR_ID;
	regs->guest_cpuid_cachetype = read_cpuid(CPUID_CACHETYPE);
	regs->guest_cpuid_tcm = read_cpuid(CPUID_TCM);
	regs->guest_cpuid_tlbtype = read_cpuid(CPUID_TLBTYPE);

	/* we disable the Guest's local irq when it starts*/
	regs->irq_disabled = PSR_I_BIT;
	set_bit(0, cpu->regs->blocked_interrupts);

	/* 
	 * read  Coprocessor Access Control Register and 
	 * read value on "struct lguest_regs" 
	 */
	asm("mrc p15, 0, %0, c1, c0, 2 @ get copro access"
        : "=r" (gcopro) : : "cc");
	regs->guest_copro = gcopro;

	/* Get the version of ARM Chip*/
	regs->guest_cpu_arch = cpu_architecture();

	/* 
	 * prepare the stack pointer for the Switcher code. 
	 */
	regs->guest_sp_offset = offsetof(struct lguest_pages, spare);

	/*
	 * initialize the hypercall structure.
	 */
	page_table_guest_hcall_init(cpu);
	for (i = 0; i < LHCALL_RING_SIZE; i++) {
		hcalls[i].arg0 = 0xffffffff;	
	}
}

